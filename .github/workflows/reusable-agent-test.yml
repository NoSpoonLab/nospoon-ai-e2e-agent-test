name: AI E2E Agent Test (Reusable)

# Reusable workflow: can be called from other repositories.
# Usage from another repo:
#
#   jobs:
#     e2e:
#       uses: <owner>/nospoon-ai-e2e-agent-test/.github/workflows/reusable-agent-test.yml@main
#       with:
#         apk_url: "https://presigned-url-or-s3://bucket/key"
#         test_file: "test/app_demo_test.json"
#         llm_provider: "claude"
#       secrets:
#         OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
#         ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

on:
  workflow_call:
    inputs:
      apk_url:
        description: 'URL to download the APK (https presigned or s3://bucket/key). Leave empty if APK is already in the repo.'
        required: false
        type: string
        default: ''
      test_file:
        description: 'Test spec JSON path relative to agent repo root'
        required: false
        type: string
        default: 'test/kokoro_agent_prod_login.json'
      test_spec_b64:
        description: 'Base64-encoded test spec JSON content. When provided, overrides test_file.'
        required: false
        type: string
        default: ''
      llm_provider:
        description: 'LLM provider to use (openai, claude)'
        required: false
        type: string
        default: 'openai'
      max_steps:
        description: 'Max agent turns per substep (default: 250)'
        required: false
        type: number
        default: 250
      report_s3_bucket:
        description: 'S3 bucket to upload the latest report (optional)'
        required: false
        type: string
        default: ''
      report_s3_region:
        description: 'S3 bucket region for report upload (optional)'
        required: false
        type: string
        default: ''
      report_s3_path:
        description: 'S3 key prefix for report upload (optional)'
        required: false
        type: string
        default: ''
      app_version:
        description: 'App version to report in notifications (optional)'
        required: false
        type: string
        default: ''
      slack_webhook_url:
        description: 'Slack incoming webhook URL (optional)'
        required: false
        type: string
        default: ''
      slack_channel:
        description: 'Slack channel to post to (optional)'
        required: false
        type: string
        default: ''
      slack_message:
        description: 'Optional message to prepend in Slack notification'
        required: false
        type: string
        default: ''
    outputs:
      result:
        description: '"passed" or "failed"'
        value: ${{ jobs.run-agent.outputs.result }}
      ok:
        description: '"true" or "false"'
        value: ${{ jobs.run-agent.outputs.ok }}
      summary:
        description: 'Full JSON summary of the test run'
        value: ${{ jobs.run-agent.outputs.summary }}
    secrets:
      OPENAI_API_KEY:
        required: false
      ANTHROPIC_API_KEY:
        required: false
      AWS_ACCESS_KEY_ID:
        required: false
      AWS_SECRET_ACCESS_KEY:
        required: false
      AWS_REGION:
        required: false

jobs:
  run-agent:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      result: ${{ steps.test.outputs.result }}
      ok: ${{ steps.test.outputs.ok }}
      summary: ${{ steps.test.outputs.summary }}
    steps:
      - name: Checkout agent framework
        uses: actions/checkout@v4
        with:
          repository: NoSpoonLab/nospoon-ai-e2e-agent-test
          ref: master
          lfs: true

      - name: Enable KVM
        run: |
          echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
          sudo udevadm control --reload-rules
          sudo udevadm trigger --name-match=kvm

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Set up Java (JDK)
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Make scripts executable
        run: chmod +x scripts/adb_wait_ready.sh

      - name: Install prerequisites
        run: |
          sudo apt-get update -y
          sudo apt-get install -y unzip curl jq
          pip install awscli

      - name: Set up Android SDK
        run: |
          export ANDROID_SDK_ROOT="$HOME/android-sdk"
          mkdir -p "$ANDROID_SDK_ROOT/cmdline-tools"
          curl -fsSL -o /tmp/commandlinetools.zip https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip
          unzip -q /tmp/commandlinetools.zip -d "$ANDROID_SDK_ROOT/cmdline-tools"
          mv "$ANDROID_SDK_ROOT/cmdline-tools/cmdline-tools" "$ANDROID_SDK_ROOT/cmdline-tools/latest"
          echo "ANDROID_SDK_ROOT=$ANDROID_SDK_ROOT" >> $GITHUB_ENV
          echo "ANDROID_HOME=$ANDROID_SDK_ROOT" >> $GITHUB_ENV
          echo "ANDROID_SDK_HOME=$HOME/.android" >> $GITHUB_ENV
          echo "ANDROID_AVD_HOME=$HOME/.android/avd" >> $GITHUB_ENV
          mkdir -p "$HOME/.android/avd"
          echo "PATH=$ANDROID_SDK_ROOT/platform-tools:$ANDROID_SDK_ROOT/emulator:$ANDROID_SDK_ROOT/cmdline-tools/latest/bin:$PATH" >> $GITHUB_ENV

      - name: Install custom device profile
        run: |
          mkdir -p "$HOME/android-sdk/devices"
          cp ci/hardware-device.xml "$HOME/android-sdk/devices/AI_Device.xml"

      - name: Install Android SDK packages
        run: |
          yes | sdkmanager --licenses || true
          yes | sdkmanager --install "platform-tools" "platforms;android-34" "build-tools;34.0.0" "emulator" "system-images;android-34;google_apis_playstore;x86_64"

      - name: Create and configure AVD
        run: |
          mkdir -p "$ANDROID_AVD_HOME"
          echo no | avdmanager create avd -n AI_Device -k "system-images;android-34;google_apis_playstore;x86_64" --device "AI Device" --force || \
          echo no | avdmanager create avd -n AI_Device -k "system-images;android-34;google_apis_playstore;x86_64" --force

          # Apply CI hardware config
          AVD_DIR="$ANDROID_AVD_HOME/AI_Device.avd"
          cp "$AVD_DIR/config.ini" "$AVD_DIR/config.ini.orig"
          cp ci/hardware-config.ini "$AVD_DIR/config.custom.ini"
          LINUX_IMG_DIR="$ANDROID_SDK_ROOT/system-images/android-34/google_apis_playstore/x86_64/"
          while IFS= read -r line; do
            if echo "$line" | grep -qE '^[A-Za-z0-9_.]+='; then
              key="$(echo "$line" | cut -d'=' -f1)"
              val="$(echo "$line" | cut -d'=' -f2-)"
              if [ "$key" = "AvdId" ] || [ "$key" = "avd.ini.displayname" ]; then continue; fi
              if [ "$key" = "image.sysdir.1" ]; then val="$LINUX_IMG_DIR"; fi
              if grep -qE "^${key}=" "$AVD_DIR/config.ini"; then
                sed -i "s|^${key}=.*|${key}=${val}|" "$AVD_DIR/config.ini"
              else
                echo "$key=$val" >> "$AVD_DIR/config.ini"
              fi
            fi
          done < "$AVD_DIR/config.custom.ini"

      - name: Start emulator
        run: |
          mkdir -p "$HOME/.android"
          if [ ! -f "$HOME/.android/adbkey" ]; then
            "$ANDROID_SDK_ROOT/platform-tools/adb" keygen "$HOME/.android/adbkey" || true
          fi
          export ADB_VENDOR_KEYS="$HOME/.android/adbkey"

          start_emulator() {
            ACCEL=""; [ ! -e /dev/kvm ] && ACCEL="-no-accel"
            "$ANDROID_SDK_ROOT/emulator/emulator" -avd AI_Device -no-window -no-boot-anim -no-snapshot -gpu swiftshader_indirect $ACCEL -camera-back none -camera-front none -skip-adb-auth -logcat '*:W' -verbose >/tmp/emulator.log 2>&1 &
            echo "Emulator PID: $!"
          }

          wait_boot() {
            adb wait-for-device
            for i in {1..240}; do
              boot_completed=$(adb shell getprop sys.boot_completed 2>/dev/null | tr -d '\r')
              boot_anim=$(adb shell getprop init.svc.bootanim 2>/dev/null | tr -d '\r')
              if [ "$boot_completed" = "1" ] || [ "$boot_anim" = "stopped" ]; then return 0; fi
              sleep 3
            done
            return 1
          }

          ensure_adb_online() {
            for i in {1..30}; do
              state=$(adb get-state 2>/dev/null || true)
              if [ "$state" = "device" ]; then return 0; fi
              adb kill-server || true; adb start-server || true
              adb reconnect offline || true; sleep 2
            done
            return 1
          }

          start_emulator
          if wait_boot && ensure_adb_online; then
            echo "Emulator is ready."
          else
            echo "First attempt failed. Retrying with safer flags..."
            adb -e emu kill || true; sleep 5
            ACCEL=""; [ ! -e /dev/kvm ] && ACCEL="-no-accel"
            "$ANDROID_SDK_ROOT/emulator/emulator" -avd AI_Device -no-window -no-boot-anim -no-snapshot -gpu swiftshader_indirect $ACCEL -camera-back none -camera-front none -no-audio -no-jni -qt-hide-window -skip-adb-auth >/tmp/emulator.log 2>&1 &
            if ! wait_boot || ! ensure_adb_online; then
              echo "Emulator failed to boot."; tail -n 400 /tmp/emulator.log || true; exit 1
            fi
            echo "Emulator is ready (retry)."
          fi

      - name: Configure AWS credentials
        if: ${{ startsWith(inputs.apk_url, 's3://') }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Download APK from URL
        if: ${{ inputs.apk_url != '' }}
        run: |
          mkdir -p apk
          URL="${{ inputs.apk_url }}"
          if [[ "$URL" == s3://* ]]; then
            aws s3 cp "$URL" apk/app-under-test.apk
          else
            curl -fSL "$URL" -o apk/app-under-test.apk
          fi
          echo "APK downloaded:"; ls -lh apk/app-under-test.apk

      - name: Prepare test spec
        id: spec
        run: |
          SPEC_B64="${{ inputs.test_spec_b64 }}"
          if [ -n "$SPEC_B64" ]; then
            echo "$SPEC_B64" | base64 -d > test/_dynamic_spec.json
            echo "test_file=test/_dynamic_spec.json" >> $GITHUB_OUTPUT
            echo "Using dynamic test spec (decoded from base64)"
          else
            echo "test_file=${{ inputs.test_file }}" >> $GITHUB_OUTPUT
            echo "Using test file: ${{ inputs.test_file }}"
          fi

      - name: Run agent test
        id: test
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          LLM_PROVIDER: ${{ inputs.llm_provider }}
        run: |
          adb devices | cat
          ./scripts/adb_wait_ready.sh
          TEST_FILE="${{ steps.spec.outputs.test_file }}"
          echo "Running test: $TEST_FILE (provider: $LLM_PROVIDER)"
          # Pre-install APK if available
          if [ -f apk/app-under-test.apk ]; then
            adb -e install -t -r apk/app-under-test.apk || true
          else
            APK_PATH=$(python -c "import json; d=json.load(open('$TEST_FILE')); print(d.get('apk',''))" 2>/dev/null || true)
            if [ -n "$APK_PATH" ] && [ -f "$APK_PATH" ]; then
              adb -e install -t -r "$APK_PATH" || true
            fi
          fi
          EXIT_CODE=0
          python -m source.agent_runner "$TEST_FILE" --max-steps ${{ inputs.max_steps }} || EXIT_CODE=$?
          # Extract result from the latest summary JSON
          SUMMARY_FILE=$(find reports -name "summary.json" -type f 2>/dev/null | sort | tail -1)
          if [ -n "$SUMMARY_FILE" ]; then
            OK=$(python -c "import json; d=json.load(open('$SUMMARY_FILE')); print(str(d.get('ok',False)).lower())")
            RESULT=$(python -c "import json; d=json.load(open('$SUMMARY_FILE')); print(d.get('result','unknown'))")
            SUMMARY=$(cat "$SUMMARY_FILE")
            echo "ok=$OK" >> $GITHUB_OUTPUT
            echo "result=$RESULT" >> $GITHUB_OUTPUT
            echo "summary<<EOF" >> $GITHUB_OUTPUT
            echo "$SUMMARY" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "ok=false" >> $GITHUB_OUTPUT
            echo "result=error" >> $GITHUB_OUTPUT
            echo "summary={}" >> $GITHUB_OUTPUT
          fi
          exit $EXIT_CODE

      - name: Resolve report directory
        if: always()
        id: report_dir
        run: |
          REPORT_SUMMARY=$(find reports -name "summary.json" -type f 2>/dev/null | sort | tail -1)
          if [ -z "$REPORT_SUMMARY" ]; then
            echo "dir=" >> $GITHUB_OUTPUT
            exit 0
          fi
          REPORT_DIR=$(dirname "$REPORT_SUMMARY")
          echo "dir=$REPORT_DIR" >> $GITHUB_OUTPUT

      - name: Resolve report URL
        if: always()
        id: report_url
        env:
          REPORT_S3_BUCKET: ${{ inputs.report_s3_bucket }}
          REPORT_S3_REGION: ${{ inputs.report_s3_region }}
          REPORT_S3_PATH: ${{ inputs.report_s3_path }}
          REPORT_DIR: ${{ steps.report_dir.outputs.dir }}
        run: |
          if [ -n "$REPORT_S3_BUCKET" ] && [ -n "$REPORT_S3_REGION" ] && [ -n "$REPORT_DIR" ]; then
            base="https://${REPORT_S3_BUCKET}.s3.${REPORT_S3_REGION}.amazonaws.com"
            if [ -n "$REPORT_S3_PATH" ]; then
              echo "url=${base}/${REPORT_S3_PATH}/report.html" >> $GITHUB_OUTPUT
            else
              base_dir=$(basename "$REPORT_DIR")
              echo "url=${base}/reports/${base_dir}/report.html" >> $GITHUB_OUTPUT
            fi
            exit 0
          fi
          echo "url=" >> $GITHUB_OUTPUT

      - name: Build S3 destination
        if: ${{ always() && inputs.report_s3_bucket != '' && inputs.report_s3_region != '' && steps.report_dir.outputs.dir != '' }}
        id: s3_dest
        env:
          REPORT_S3_BUCKET: ${{ inputs.report_s3_bucket }}
          REPORT_S3_PATH: ${{ inputs.report_s3_path }}
          REPORT_DIR: ${{ steps.report_dir.outputs.dir }}
        run: |
          dest="$REPORT_S3_BUCKET"
          if [ -n "$REPORT_S3_PATH" ]; then
            dest="$dest/$REPORT_S3_PATH"
          else
            base_dir=$(basename "$REPORT_DIR")
            dest="$dest/reports/$base_dir"
          fi
          echo "bucket=$dest" >> $GITHUB_OUTPUT

      - name: Upload report to S3
        if: ${{ always() && inputs.report_s3_bucket != '' && inputs.report_s3_region != '' && steps.report_dir.outputs.dir != '' }}
        uses: reggionick/s3-deploy@v4
        with:
          folder: ${{ steps.report_dir.outputs.dir }}
          bucket: ${{ steps.s3_dest.outputs.bucket }}
          bucket-region: ${{ inputs.report_s3_region }}
          delete-removed: false
          private: true

      - name: Upload reports artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: agent-reports
          path: reports/
          if-no-files-found: warn

      - name: Resolve app version
        if: always()
        id: app_version
        env:
          INPUT_VERSION: ${{ inputs.app_version }}
        run: |
          if [ -n "$INPUT_VERSION" ]; then
            echo "version=$INPUT_VERSION" >> $GITHUB_OUTPUT
            exit 0
          fi
          APK_PATH="apk/app-under-test.apk"
          AAPT="$ANDROID_SDK_ROOT/build-tools/34.0.0/aapt"
          if [ -f "$APK_PATH" ] && [ -x "$AAPT" ]; then
            VERSION=$("$AAPT" dump badging "$APK_PATH" | sed -n "s/.*versionName='\([^']*\)'.*/\1/p" | head -n 1)
            if [ -n "$VERSION" ]; then
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          echo "version=unknown" >> $GITHUB_OUTPUT

      - name: Notify Slack
        if: ${{ always() && inputs.slack_webhook_url != '' }}
        env:
          SLACK_WEBHOOK_URL: ${{ inputs.slack_webhook_url }}
          SLACK_CHANNEL: ${{ inputs.slack_channel }}
          SLACK_MESSAGE: ${{ inputs.slack_message }}
          RESULT: ${{ steps.test.outputs.result }}
          OK: ${{ steps.test.outputs.ok }}
          REPORT_URL: ${{ steps.report_url.outputs.url }}
          APP_VERSION: ${{ steps.app_version.outputs.version }}
        run: |
          status="failed"
          [ "$OK" = "true" ] && status="passed"
          report_text="(no report URL)"
          if [ -n "$REPORT_URL" ]; then report_text="$REPORT_URL"; fi
          base_text="E2E result: ${status} | app version: ${APP_VERSION} | report: ${report_text}"
          if [ -n "$SLACK_MESSAGE" ]; then
            text="${SLACK_MESSAGE}\n${base_text}"
          else
            text="$base_text"
          fi
          payload=$(jq -n --arg text "$text" --arg channel "$SLACK_CHANNEL" 'if $channel=="" then {text:$text} else {text:$text, channel:$channel} end')
          curl -X POST -H "Content-type: application/json" --data "$payload" "$SLACK_WEBHOOK_URL"
